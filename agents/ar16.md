# AR16 Evaluation Spec for `PolyCircuit`

This document specifies **AR16 public-key evaluation (EvalPK)** and **encoding evaluation (EvalCT)** for the
`PolyCircuit` in `src/circuit/mod.rs` (branch `feat/ar16_encode`). It is implementation‑ready and aligned with the
concrete gate model:

- **Gates:** `PolyGateType::{Input, Add, Sub, Mul}` (only these three are in scope).
- **Identifiers:** Each gate has a unique `GateId(usize)`; its **output wire** is the same identifier.
- **GateId:** The message id used to index advice/labels for a gate’s **output** equals that gate’s `GateId`.

Equation numbers (5.xx) below refer to Section 5 “Public Key and Ciphertext Evaluation Algorithms” of [AR16](https://eprint.iacr.org/2016/361.pdf).

---

## Implementation TODO (2025-10-17)

- [x] **Module scaffold** – recreate `src/ar16/` with clear submodules (`mod.rs` re-exports plus `advice`, `context`, `encoding`, `pk`, `quadratic`, `error`) matching the structure below.  
- [x] **Core types** – implement `Level`, `AR16PublicKey`, and `AR16Encoding` from Section 2 with level-aware arithmetic helpers and evaluation functions.  
- [x] **Advice representation** – materialise the `C_k` hierarchy per Section 3 via `AdviceKey/AdviceRole` enums and collection types that return `E_k(s^2)`, `E_k(z)`, and `E_k(z·s)` by gate.  
- [x] **Evaluation context** – add an `EvalContext` storing advice, memoisation caches, and level annotations.  
- [x] **Level annotation** – provide `determine_gate_level` enforcing the level recursion in Section 1.  
- [x] **EvalPK** – implement public-key evaluation (circuit and gate level) covering equations (5.9)–(5.25), including advice lookups for multiplication gates.  
- [x] **EvalCT** – implement ciphertext evaluation analogously, combining encodings as in (5.24) and reusing reconstructed `E_k(c^{k-1}·s)`.  
- [x] **Quadratic helper** – implement reconstruction of `E_k(c^{k-1}·s)` using the quadratic method ((5.6)–(5.19)) with memoisation for both first and later multiplication levels.  
- [x] **Error handling** – create `Ar16Error` variants for missing advice, unsupported gates, and level mismatches.  
- [x] **Zero-noise tests** – supply deterministic fixtures ensuring Equation (5.1) holds with zero noise for both intermediate and output wires (per user request).  
- [x] **Documentation** – reference the relevant equation numbers from §5 in code comments, keeping English-only annotations per repo guidelines.

---

## 1. Notation & Levels

A depth‑`d` circuit alternates addition and multiplication layers with a modulus tower
`p0 < p1 = p2 < p3 = … < pd`. Encodings at level `k` live in `R_{p_k}`, while messages of those encodings live in
`R_{p_{k-1}}`. **Addition** does not raise the modulus; **multiplication** does.

- Inputs (and a constant‑one gate if present) are **level 0** values.
- For `Add/Sub(i,j)`: `level(out) = max(level(i), level(j))`.
- For `Mul(i,j)`: `level(out) = max(level(i), level(j)) + 1` (this is the *first multiplication layer* if it is the smallest `> 0` where a `Mul` appears).

```rust
#[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct Level(pub u32);
```

**Encoding form.** A level‑`k` Regev‑style encoding of a message `y ∈ R_{p_{k-1}}` is
```
E_k(y) = u_k · s + p_{k-1} · η_k + y  ∈ R_{p_k},
```
where `s` is a fixed (hidden) secret, `η_k` is noise, and `u_k` is a **public label** (the functional public key).

---

## 2. Core Data Types (concrete fields)

Implementations operate over `crate::poly::Poly` (reduced mod the appropriate `p_k`). **An encoding’s level is carried only by its label.**

```rust
use crate::poly::Poly; // ring element reduced mod p_k

/// Functional public key / label (single ring element, level-tagged).
pub struct AR16PublicKey {
    pub level: Level,   // k
    pub u: Poly,        // u_k ∈ R_{p_k}
}

/// AR16 encoding at level k.
/// Invariant: the level is derived from `label.level`; do not store a separate level here.
pub struct AR16Encoding {
    pub label: AR16PublicKey, // carries the level k
    pub c: Poly,              // ciphertext body in R_{p_k}
}

// Minimal ops expected by evaluation (ring-safe and level-checked).
impl std::ops::Add for AR16Encoding { /* R_{p_k} add; assert label.level equal */ }
impl std::ops::Sub for AR16Encoding { /* R_{p_k} sub; assert label.level equal */ }
impl std::ops::Mul for AR16Encoding { /* R_{p_k} mul; used for quadratic terms */ }

impl AR16PublicKey {
    pub fn level(&self) -> Level { self.level }
}
```

> We represent an encoding as a **single ring element `c` plus a public label `u`** (not an `(a,b)` pair), matching the algebra in §5 where labels scale encodings as ring elements.

---

## 3. Advice Data `C_k` (content, indexing, storage)

The evaluator receives **advice encodings** so it can assemble gate outputs without secrets. Define per‑level advice sets:

- **Level 1 (inputs):**
  ```
  C_1 = { E_1(x_i) for each input gate i }  ∪  { E_1(s) }.
  ```
- **Addition layer (general):** `C_k := C_{k-1}` (no new advice).
- **Multiplication layer (general):**
  ```
  C_k = { E_k(z)     for every z ∈ C_{k-1} }
      ∪ { E_k(z·s)   for every z ∈ C_{k-1} }
      ∪ { E_k(s^2) }.
  ```

**Indexing.** All entries are keyed by **producing GateId**:

- `E_1(x_i)` → key `Msg(i)` for `i: GateId`.
- `E_k(z)` and `E_k(z·s)` inherit the key of `z` (the gate that produced that message).
- `E_k(s^2)` → reserved key `S2(k)`.

If `|C_{k-1}| = L_{k-1}`, then `|C_k| = 2·L_{k-1} + 1`.

### 3.1 Rust-side shape

```rust
pub enum AdviceKey { Msg(GateId), S2(Level) }

pub struct Advice {
    // Level 1
    pub c1_x: BTreeMap<GateId, AR16Encoding>, // E_1(x_i)
    pub c1_s: AR16Encoding,                   // E_1(s)

    // For k ≥ 2: index by (k-2)
    pub lift:   Vec<BTreeMap<AdviceKey, AR16Encoding>>, // E_k(z) and E_k(s^2)
    pub lift_s: Vec<BTreeMap<AdviceKey, AR16Encoding>>, // E_k(z·s)
}

impl Advice {
    pub fn e1_x(&self, i: GateId) -> &AR16Encoding { &self.c1_x[&i] }
    pub fn e1_s(&self) -> &AR16Encoding { &self.c1_s }
    pub fn ek_s2(&self, k: Level) -> &AR16Encoding { &self.lift[(k.0-2) as usize][&AdviceKey::S2(k)] }
    pub fn ek_of(&self, k: Level, m: GateId) -> &AR16Encoding { &self.lift[(k.0-2) as usize][&AdviceKey::Msg(m)] }
    pub fn ek_times_s_of(&self, k: Level, m: GateId) -> &AR16Encoding { &self.lift_s[(k.0-2) as usize][&AdviceKey::Msg(m)] }
}
```

> **Is `Advice` required for EvalPK?** **Yes.** At a multiplication gate, EvalPK needs the **level‑`k` labels** of `E_k(s^2)` and `E_k(c^{k-1}_•·s)` to assemble the output label exactly as in (5.25). For efficiency, EvalPK may read from a **labels‑only projection** (`AdvicePK`) that stores `AR16PublicKey` instead of full encodings, but semantically it depends on the same `C_k` content.

---

## 4. Public API (circuit‑level versus gate‑level)

**Circuit‑level drivers** evaluate all gates in topological order; **gate‑level evaluators** compute a single gate recursively with memoization. We use `PolyCircuit` and `PolyGateType` (Add/Sub/Mul only).

```rust
use std::collections::{BTreeMap, HashMap};
use crate::circuit::{PolyCircuit, gate::{GateId, PolyGateType}};

/// Compute AR16 public keys (labels u_k) for all gates.
pub fn eval_ar16_public_keys(
    poly: &PolyCircuit,
    advice: &Advice, // or labels-only AdvicePK
) -> BTreeMap<GateId, AR16PublicKey>;

/// Compute AR16 encodings (c_k with labels u_k) for all gates.
pub fn eval_ar16_encodings(
    poly: &PolyCircuit,
    advice: &Advice,
) -> BTreeMap<GateId, AR16Encoding>;

/// Gate-level: label of gate `g`.
pub fn eval_pk_gate(
    poly: &PolyCircuit, g: GateId, advice: &Advice,
    memo_pk: &mut HashMap<GateId, AR16PublicKey>,
) -> AR16PublicKey;

/// Gate-level: encoding of gate `g`.
pub fn eval_ct_gate(
    poly: &PolyCircuit, g: GateId, advice: &Advice,
    memo_ct: &mut HashMap<GateId, AR16Encoding>,
    memo_times_s: &mut HashMap<(Level, GateId), AR16Encoding>, // cache of E_k(c^{k-1}_g · s)
) -> AR16Encoding;
```

---

## 5. Gate Semantics (EvalCT / EvalPK)

Let a gate `g` have inputs `(i, j)` if applicable, and `k = level(g)`.

### 5.1 Add / Sub (levels unchanged)

**Ciphertexts (5.9):** `c_out = c_i + c_j`  
**Labels (5.10):** `u_out = u_i + u_j`  
Subtraction is the signed variant. Both inputs must have the same level `k` (assert).

```rust
match poly.gate(g).unwrap().gate_type {
    PolyGateType::Add(a, b) => {
        let ca = eval_ct_gate(poly, a, advice, memo_ct, memo_times_s);
        let cb = eval_ct_gate(poly, b, advice, memo_ct, memo_times_s);
        return ca + cb;
    }
    PolyGateType::Sub(a, b) => {
        let ca = eval_ct_gate(poly, a, advice, memo_ct, memo_times_s);
        let cb = eval_ct_gate(poly, b, advice, memo_ct, memo_times_s);
        return ca - cb;
    }
    PolyGateType::Mul(_, _) => { /* see 5.2 */ }
    _ => unreachable!("out of scope"),
}
```

### 5.2 Mul (level changes)

Let a multiplication gate `w` at level `k` have children `(i, j)` at level `k-1`. Denote
`u_{k-1,i} := PK(E_{k-1}(c_{k-2}^i))` and `u_{k-1,j·s} := PK(E_{k-1}(c_{k-2}^j · s))`. Then:

#### 5.2.1 Reduction (Equation 5.18)

```
E_k(c_{k-1} · s)
= E_k(c_{k-2}^i c_{k-2}^j s)
  − u_{k-2,i} · E_k(E_{k-1}(c_{k-2}^j · s) · s)
  − u_{k-2,j} · E_k(E_{k-1}(c_{k-2}^i) · s)
  + u_{k-2,i} u_{k-2,j} · E_k(E_{k-1}(s^2) · s).
```

All three nested `E_k(E_{k-1}(·)·s)` terms are present *verbatim* in the advice set `C_k` because
`C_k` contains `E_k(z·s)` for every `z ∈ C_{k-1}` (and `E_{k-1}(s^2) ∈ C_{k-1}` by definition).

#### 5.2.2 Quadratic step (Equation 5.19)

```
E_k(c_{k-2}^i c_{k-2}^j s)
= [ E_{k-1}(c_{k-2}^i) · E_{k-1}(c_{k-2}^j · s) ]
  + PK(E_{k-1}(c_{k-2}^i)) · PK(E_{k-1}(c_{k-2}^j · s)) · E_k(s^2)
  − PK(E_{k-1}(c_{k-2}^i)) · E_k(E_{k-1}(c_{k-2}^j · s) · s)
  − PK(E_{k-1}(c_{k-2}^j · s)) · E_k(E_{k-1}(c_{k-2}^i) · s).
```

Notes:
- The square-bracketed product is the **direct product in R_{p_k}** of two level‑`k−1` encodings.
- The scalar coefficients are *public labels* (`AR16PublicKey.u`) of those level‑`k−1` encodings.
- The three `E_k(…·s)` terms are read from `C_k`. The single `E_k(s^2)` is `advice.ek_s2(k)`.

#### 5.2.3 First multiplication layer (base case)

At the first multiplication level `k = k*`, `reconstruct_ck_times_s` is just the **quadratic method**
from (5.6)–(5.14): treat `c^{k*-1}_i` and `c^{k*-1}_j·s` as the quadratic pair; assemble
`E_{k*}(c^{k*-1}_i c^{k*-1}_j s)` exactly as in §4.2 above (the same shape, with indices specialised).

---

### 5.3 Pseudo‑code: `reconstruct_ck_times_s`

```rust
/// Build E_k(c^{k-1}_w · s) for the output wire `w` of a Mul gate at level k.
fn reconstruct_ck_times_s(
    k: Level,
    w: GateId,
    poly: &PolyCircuit,
    advice: &Advice,
    memo_ct: &mut HashMap<GateId, AR16Encoding>,          // E_{t}(c^{t-1}_•)
    memo_times_s: &mut HashMap<(Level, GateId), AR16Encoding>, // E_k(c^{k-1}_• · s)
    memo_pk: &mut HashMap<GateId, AR16PublicKey>,          // labels for coeffs
) -> AR16Encoding {
    if let Some(e) = memo_times_s.get(&(k, w)) { return e.clone(); }

    // Base case: first multiplication layer
    if is_first_mul_level(k) {
        // Treat (ci, cjs) = (E_{k-1}(c^{k-2}_i), E_{k-1}(c^{k-2}_j · s)).
        let (i, j) = poly.inputs_of(w).expect("Mul gate");
        let ci  = eval_ct_gate(poly, i, advice, memo_ct, memo_times_s, memo_pk);
        let cjs = reconstruct_ck_times_s(k-1, j, poly, advice, memo_ct, memo_times_s, memo_pk);
        let ui  = eval_pk_gate(poly, i, advice.labels_only(), memo_pk).u;
        let ujs = eval_pk_of_times_s(k-1, j, poly, advice, memo_pk); // label of E_{k-1}(c^{k-2}_j · s)

        let s2k = advice.ek_s2(k); // E_k(s^2)
        // Quadratic method (Eq. 5.19 specialised to the base indices):
        let prod   = ci.mul_ring(&cjs, k); // R_{p_k} product
        let cross1 = ui * ujs * s2k.clone();
        let cross2 = ui * advice.ek_of_message_times_s(k, &cjs); // E_k(E_{k-1}(c^{k-2}_j · s)·s)
        let cross3 = ujs * advice.ek_of_message_times_s(k, &ci); // E_k(E_{k-1}(c^{k-2}_i)·s)
        let res = prod + cross1 - cross2 - cross3;
        memo_times_s.insert((k, w), res.clone());
        return res;
    }

    // Inductive step: one reduction (5.18) + one quadratic (5.19)
    let (i, j) = poly.inputs_of(w).expect("Mul gate");
    // Terms for the quadratic step:
    let ci  = eval_ct_gate(poly, i, advice, memo_ct, memo_times_s, memo_pk);       // E_{k-1}(c^{k-2}_i)
    let cjs = reconstruct_ck_times_s(k-1, j, poly, advice, memo_ct, memo_times_s, memo_pk); // E_{k-1}(c^{k-2}_j · s)

    let ui  = eval_pk_gate(poly, i, advice.labels_only(), memo_pk).u;              // PK(E_{k-1}(c^{k-2}_i))
    let ujs = eval_pk_of_times_s(k-1, j, poly, advice, memo_pk);                   // PK(E_{k-1}(c^{k-2}_j · s))

    let s2k = advice.ek_s2(k);                                                     // E_k(s^2)
    let t_js = advice.ek_of_message_times_s(k, &cjs); // E_k(E_{k-1}(c^{k-2}_j · s) · s) ∈ C_k
    let t_i  = advice.ek_of_message_times_s(k, &ci);  // E_k(E_{k-1}(c^{k-2}_i) · s)     ∈ C_k

    // Quadratic (5.19):
    let q = ci.mul_ring(&cjs, k)                   // E_{k-1}(ci) · E_{k-1}(cjs)
            + (ui * ujs) * s2k.clone()
            - ui * t_js
            - ujs * t_i;

    // Reduction (5.18): add remaining linear terms in one pass
    // E_k(c_{k-1}·s) = q  − u_{k-2,i}·E_k(E_{k-1}(c_{k-2}^j · s)·s) − u_{k-2,j}·E_k(E_{k-1}(c_{k-2}^i)·s) + u_{k-2,i}u_{k-2,j}·E_k(E_{k-1}(s^2)·s).
    let ui_prev = eval_pk_gate(poly, i, advice.labels_only(), memo_pk).u_prev_level();
    let uj_prev = eval_pk_gate(poly, j, advice.labels_only(), memo_pk).u_prev_level();
    let s2k_s   = advice.ek_of_message_times_s(k, &advice.ek_s2(k-1).as_message()); // E_k(E_{k-1}(s^2)·s)

    let res = q
        - ui_prev * t_js
        - uj_prev * t_i
        + (ui_prev * uj_prev) * s2k_s;
    memo_times_s.insert((k, w), res.clone());
    res
}
```

**Helper contracts.**

- `eval_pk_of_times_s(ℓ, g, …)` returns the label of `E_ℓ(c^{ℓ-1}_g · s)` by reusing the same linear
  combination as `reconstruct_ck_times_s` but collapsing to labels only (see Eq. (5.23)).
- `advice.ek_of_message_times_s(k, &m)` fetches `E_k(m·s)` where `m ∈ C_{k-1}`—this is a direct
  lookup in `C_k`. In practice you pass `m = E_{k-1}(c^{k-2}_•)` or `m = E_{k-1}(c^{k-2}_• · s)`.
- `u_prev_level()` returns the parent label needed by the linear coefficients in (5.18).
  (Implement as part of your `AR16PublicKey` if you cache both current and parent labels.)

---

## 6) Assembling gate outputs (EvalCT / EvalPK)

Let the gate `w` be `Mul(i, j)` at level `k`. Then:

**Ciphertexts (Eq. 5.24):**
```
c_k(w) = c_{k-1}(i) · c_{k-1}(j)
         + (u_{k-1,i} · u_{k-1,j}) · E_k(s^2)
         − u_{k-1,j} · E_k(c_{k-1}(i) · s)
         − u_{k-1,i} · E_k(c_{k-1}(j) · s).
```

**Labels (Eq. 5.25):**
```
PK(c_k(w)) = (u_{k-1,i} · u_{k-1,j}) · PK(E_k(s^2))
             − u_{k-1,j} · PK(E_k(c_{k-1}(i) · s))
             − u_{k-1,i} · PK(E_k(c_{k-1}(j) · s)).
```

**Add/Sub (Eqs. 5.9–5.10):**
```
c_k(w) = c_{k-1}(i) ± c_{k-1}(j),     PK(c_k(w)) = PK(c_{k-1}(i)) ± PK(c_{k-1}(j)).
```

---

## 7) Worked mini‑example (base layer shape)

At `k = 4` (first multiplication after level‑3 addition), for children `(i,j)` and `(m,t)`:

```
c_4 = c_3(i,j) · c_3(m,t)
    + u_3(i,j)·u_3(m,t) · E_4(s^2)
    − u_3(m,t) · E_4(c_3(i,j)·s)
    − u_3(i,j) · E_4(c_3(m,t)·s).     // (Eq. 5.11)
```

To expand `E_4(c_3(i,j)·s)`, first *reduce* to terms that are all in `C_4` plus the quadratic term
`E_4(c_1^i c_1^j s)`; then *apply the quadratic* again to that term using the pair
`(E_2(c_1^i), E_2(c_1^j·s))` (Eq. 5.14). This matches the pseudo‑code above.

---



## 6. Traversal & Levels

Evaluate the circuit in **topological order**. If levels are not precomputed, annotate once:

```rust
/// Inputs/const-one → level 0; Add/Sub keep max(level); Mul raises by +1.
pub fn annotate_levels(poly: &PolyCircuit) -> HashMap<GateId, Level> { /* standard pass */ }
```

Enforce for Add/Sub that both inputs are at the same level; multiply raises by +1 deterministically.

---

## 7. Advice Generation (offline)

For a depth‑`d` layered circuit:
1. Build `C_1 = {E_1(x_i)}_i ∪ {E_1(s)}`.
2. For `k = 2..d`:
   - If layer `k` is **addition**: `C_k := C_{k-1}`.
   - If layer `k` is **multiplication**: materialize  
     `C_k = {E_k(z), E_k(z·s) : z∈C_{k-1}} ∪ {E_k(s^2)}`.

This is a **minimal sufficient** advice family for all EvalPK/EvalCT steps (both base case and inductive).

---

## 8. Design Q&A

- **Is `Advice` required by EvalPK?**  
  Yes, but please provide a labels‑only `AdvicePK`, but its content mirrors `C_k`.
---

## 9. Tests

- **Add/Sub**: Check (5.9)/(5.10) with noise neutralized in fixtures.  
- **First Mul**: Quadratic method matches (5.7)/(5.11) for both CT and PK.  
- **Later Mul**: Reconstruction follows (5.18)/(5.19); final assembly equals (5.24)/(5.25).  
- **Structure**: For random circuits, verify `c^k = ⟨Lin^k, C_k⟩ + Poly^k(C_1..C_{k-1})` (5.2)–(5.4).

---

## 10. References

- 2016 paper, §5 “Public Key and Ciphertext Evaluation Algorithms” (esp. (5.2)–(5.25)).
- `PolyCircuit`, `GateId`, `PolyGateType::{Input, Add, Sub, Mul}` in your codebase.
