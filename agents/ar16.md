# AR16 Evaluation Spec for `PolyCircuit`

This document specifies **AR16 public-key evaluation (EvalPK)** and **encoding evaluation (EvalCT)** for the
`PolyCircuit` in `src/circuit/mod.rs` (branch `feat/ar16_encode`). It is implementation‑ready and aligned with the
concrete gate model:

- **Gates:** `PolyGateType::{Input, Add, Sub, Mul}` (only these three are in scope).
- **Identifiers:** Each gate has a unique `GateId(usize)`; its **output wire** is the same identifier.
- **GateId:** The message id used to index advice/labels for a gate’s **output** equals that gate’s `GateId`.

Equation numbers (5.xx) below refer to Section 5 “Public Key and Ciphertext Evaluation Algorithms” of [AR16](https://eprint.iacr.org/2016/361.pdf).

---

## Implementation TODO (2025-10-17)

- [x] **Module scaffold** – recreate `src/ar16/` with clear submodules (`mod.rs` re-exports plus `advice`, `context`, `encoding`, `pk`, `quadratic`, `error`) matching the structure below.  
- [x] **Core types** – implement `Level`, `AR16PublicKey`, and `AR16Encoding` from Section 2 with level-aware arithmetic helpers and evaluation functions.  
- [x] **Advice representation** – materialise the `C_k` hierarchy per Section 3 via `AdviceKey/AdviceRole` enums and collection types that return `E_k(s^2)`, `E_k(z)`, and `E_k(z·s)` by gate.  
- [x] **Evaluation context** – add an `EvalContext` storing advice, memoisation caches, and level annotations.  
- [x] **Level annotation** – provide `determine_gate_level` enforcing the level recursion in Section 1.  
- [x] **EvalPK** – implement public-key evaluation (circuit and gate level) covering equations (5.9)–(5.25), including advice lookups for multiplication gates.  
- [x] **EvalCT** – implement ciphertext evaluation analogously, combining encodings as in (5.24) and reusing reconstructed `E_k(c^{k-1}·s)`.  
- [x] **Quadratic helper** – implement reconstruction of `E_k(c^{k-1}·s)` using the quadratic method ((5.6)–(5.19)) with memoisation for both first and later multiplication levels.  
- [x] **Error handling** – create `Ar16Error` variants for missing advice, unsupported gates, and level mismatches.  
- [x] **Zero-noise tests** – supply deterministic fixtures ensuring Equation (5.1) holds with zero noise for both intermediate and output wires (per user request).  
- [x] **Documentation** – reference the relevant equation numbers from §5 in code comments, keeping English-only annotations per repo guidelines.

---

## 1. Notation & Levels

A depth‑`d` circuit alternates addition and multiplication layers with a modulus tower
`p0 < p1 = p2 < p3 = … < pd`. Encodings at level `k` live in `R_{p_k}`, while messages of those encodings live in
`R_{p_{k-1}}`. **Addition** does not raise the modulus; **multiplication** does.

- Inputs (and a constant‑one gate if present) are **level 0** values.
- For `Add/Sub(i,j)`: `level(out) = max(level(i), level(j))`.
- For `Mul(i,j)`: `level(out) = max(level(i), level(j)) + 1` (this is the *first multiplication layer* if it is the smallest `> 0` where a `Mul` appears).

```rust
#[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct Level(pub u32);
```

**Encoding form.** A level‑`k` Regev‑style encoding of a message `y ∈ R_{p_{k-1}}` is
```
E_k(y) = u_k · s + p_{k-1} · η_k + y  ∈ R_{p_k},
```
where `s` is a fixed (hidden) secret, `η_k` is noise, and `u_k` is a **public label** (the functional public key).

---

## 2. Core Data Types (concrete fields)

Implementations operate over `crate::poly::Poly` (reduced mod the appropriate `p_k`). **An encoding’s level is carried only by its label.**

```rust
use crate::poly::Poly; // ring element reduced mod p_k

/// Functional public key / label (single ring element, level-tagged).
pub struct AR16PublicKey {
    pub level: Level,   // k
    pub u: Poly,        // u_k ∈ R_{p_k}
}

/// AR16 encoding at level k.
/// Invariant: the level is derived from `label.level`; do not store a separate level here.
pub struct AR16Encoding {
    pub label: AR16PublicKey, // carries the level k
    pub c: Poly,              // ciphertext body in R_{p_k}
}

// Minimal ops expected by evaluation (ring-safe and level-checked).
impl std::ops::Add for AR16Encoding { /* R_{p_k} add; assert label.level equal */ }
impl std::ops::Sub for AR16Encoding { /* R_{p_k} sub; assert label.level equal */ }
impl std::ops::Mul for AR16Encoding { /* R_{p_k} mul; used for quadratic terms */ }

impl AR16PublicKey {
    pub fn level(&self) -> Level { self.level }
}
```

> We represent an encoding as a **single ring element `c` plus a public label `u`** (not an `(a,b)` pair), matching the algebra in §5 where labels scale encodings as ring elements.

---

## 3. Advice Data `C_k` (content, indexing, storage)

The evaluator receives **advice encodings** so it can assemble gate outputs without secrets. Define per‑level advice sets:

- **Level 1 (inputs):**
  ```
  C_1 = { E_1(x_i) for each input gate i }  ∪  { E_1(s) }.
  ```
- **Addition layer (general):** `C_k := C_{k-1}` (no new advice).
- **Multiplication layer (general):**
  ```
  C_k = { E_k(z)     for every z ∈ C_{k-1} }
      ∪ { E_k(z·s)   for every z ∈ C_{k-1} }
      ∪ { E_k(s^2) }.
  ```

**Indexing.** All entries are keyed by **producing GateId**:

- `E_1(x_i)` → key `Msg(i)` for `i: GateId`.
- `E_k(z)` and `E_k(z·s)` inherit the key of `z` (the gate that produced that message).
- `E_k(s^2)` → reserved key `S2(k)`.

If `|C_{k-1}| = L_{k-1}`, then `|C_k| = 2·L_{k-1} + 1`.

### 3.1 Rust-side shape

```rust
pub enum AdviceKey { Msg(GateId), S2(Level) }

pub struct Advice {
    // Level 1
    pub c1_x: BTreeMap<GateId, AR16Encoding>, // E_1(x_i)
    pub c1_s: AR16Encoding,                   // E_1(s)

    // For k ≥ 2: index by (k-2)
    pub lift:   Vec<BTreeMap<AdviceKey, AR16Encoding>>, // E_k(z) and E_k(s^2)
    pub lift_s: Vec<BTreeMap<AdviceKey, AR16Encoding>>, // E_k(z·s)
}

impl Advice {
    pub fn e1_x(&self, i: GateId) -> &AR16Encoding { &self.c1_x[&i] }
    pub fn e1_s(&self) -> &AR16Encoding { &self.c1_s }
    pub fn ek_s2(&self, k: Level) -> &AR16Encoding { &self.lift[(k.0-2) as usize][&AdviceKey::S2(k)] }
    pub fn ek_of(&self, k: Level, m: GateId) -> &AR16Encoding { &self.lift[(k.0-2) as usize][&AdviceKey::Msg(m)] }
    pub fn ek_times_s_of(&self, k: Level, m: GateId) -> &AR16Encoding { &self.lift_s[(k.0-2) as usize][&AdviceKey::Msg(m)] }
}
```

> **Is `Advice` required for EvalPK?** **Yes.** At a multiplication gate, EvalPK needs the **level‑`k` labels** of `E_k(s^2)` and `E_k(c^{k-1}_•·s)` to assemble the output label exactly as in (5.25). For efficiency, EvalPK may read from a **labels‑only projection** (`AdvicePK`) that stores `AR16PublicKey` instead of full encodings, but semantically it depends on the same `C_k` content.

---

## 4. Public API (circuit‑level versus gate‑level)

**Circuit‑level drivers** evaluate all gates in topological order; **gate‑level evaluators** compute a single gate recursively with memoization. We use `PolyCircuit` and `PolyGateType` (Add/Sub/Mul only).

```rust
use std::collections::{BTreeMap, HashMap};
use crate::circuit::{PolyCircuit, gate::{GateId, PolyGateType}};

/// Compute AR16 public keys (labels u_k) for all gates.
pub fn eval_ar16_public_keys(
    poly: &PolyCircuit,
    advice: &Advice, // or labels-only AdvicePK
) -> BTreeMap<GateId, AR16PublicKey>;

/// Compute AR16 encodings (c_k with labels u_k) for all gates.
pub fn eval_ar16_encodings(
    poly: &PolyCircuit,
    advice: &Advice,
) -> BTreeMap<GateId, AR16Encoding>;

/// Gate-level: label of gate `g`.
pub fn eval_pk_gate(
    poly: &PolyCircuit, g: GateId, advice: &Advice,
    memo_pk: &mut HashMap<GateId, AR16PublicKey>,
) -> AR16PublicKey;

/// Gate-level: encoding of gate `g`.
pub fn eval_ct_gate(
    poly: &PolyCircuit, g: GateId, advice: &Advice,
    memo_ct: &mut HashMap<GateId, AR16Encoding>,
    memo_times_s: &mut HashMap<(Level, GateId), AR16Encoding>, // cache of E_k(c^{k-1}_g · s)
) -> AR16Encoding;
```

---

## 5. Gate Semantics (EvalCT / EvalPK)

Let a gate `g` have inputs `(i, j)` if applicable, and `k = level(g)`.

### 5.1 Add / Sub (levels unchanged)

**Ciphertexts (5.9):** `c_out = c_i + c_j`  
**Labels (5.10):** `u_out = u_i + u_j`  
Subtraction is the signed variant. Both inputs must have the same level `k` (assert).

```rust
match poly.gate(g).unwrap().gate_type {
    PolyGateType::Add(a, b) => {
        let ca = eval_ct_gate(poly, a, advice, memo_ct, memo_times_s);
        let cb = eval_ct_gate(poly, b, advice, memo_ct, memo_times_s);
        return ca + cb;
    }
    PolyGateType::Sub(a, b) => {
        let ca = eval_ct_gate(poly, a, advice, memo_ct, memo_times_s);
        let cb = eval_ct_gate(poly, b, advice, memo_ct, memo_times_s);
        return ca - cb;
    }
    PolyGateType::Mul(_, _) => { /* see 5.2 */ }
    _ => unreachable!("out of scope"),
}
```

### 5.2 Mul — base case and later layers

For a multiplication gate at level `k` with children at level `k-1`, assemble (5.24):
```
c^k_t = c^{k-1}_i · c^{k-1}_j
      + u^{k-1}_i u^{k-1}_j · E_k(s^2)
      -           u^{k-1}_j · E_k(c^{k-1}_i · s)
      -            u^{k-1}_i · E_k(c^{k-1}_j · s).
```
The public label is (5.25):
```
PK(c^k_t) = u^{k-1}_i u^{k-1}_j · PK(E_k(s^2))
          - u^{k-1}_j · PK(E_k(c^{k-1}_i · s)) - u^{k-1}_i · PK(E_k(c^{k-1}_j · s)).
```

**Base case (first multiplication layer `k = k*`)**  
Compute `E_k(c^{k-1}_• · s)` by a single **quadratic method** using only `{E_k(s^2)} ∪ {E_k(z·s) : z∈C_{k-1}}` from level‑`k` advice. (See (5.6)–(5.14).)

**Later layers (`k > k*`)**  
Build `E_k(c^{k-1}_• · s)` via **one reduction** (5.18) followed by **one quadratic** (5.19). The result is a linear combination of level‑`k` advice (`E_k(s^2)`, `E_k(E_{k-1}(·)·s)`) plus quadratic terms in level `k−1` encodings constructed locally.

```rust
fn mul_gate_ct(
    poly: &PolyCircuit, g: GateId, advice: &Advice,
    memo_pk: &mut HashMap<GateId, AR16PublicKey>,
    memo_ct: &mut HashMap<GateId, AR16Encoding>,
    memo_times_s: &mut HashMap<(Level, GateId), AR16Encoding>,
) -> AR16Encoding {
    let (i, j, k) = inputs_and_level(poly, g);
    let ui = eval_pk_gate(poly, i, advice, memo_pk);
    let uj = eval_pk_gate(poly, j, advice, memo_pk);
    let ci = eval_ct_gate(poly, i, advice, memo_ct, memo_times_s);
    let cj = eval_ct_gate(poly, j, advice, memo_ct, memo_times_s);

    let s2  = advice.ek_s2(k).clone(); // E_k(s^2)
    let cis = reconstruct_ck_times_s(k, i, poly, advice, memo_ct, memo_times_s);
    let cjs = reconstruct_ck_times_s(k, j, poly, advice, memo_ct, memo_times_s);

    // ci, cj, s2, cis, cjs are at level k; ui, uj are labels used via their ring element `u`.
    ci * cj + (ui.u.clone() * uj.u.clone()) * s2 - uj.u.clone() * cis - ui.u.clone() * cjs
}
```

#### 5.2.1 `reconstruct_ck_times_s` (shape)

```rust
/// Build E_k(c^{k-1}_w · s) using only C_k and lower-level encodings.
fn reconstruct_ck_times_s(
    k: Level, w: GateId, poly: &PolyCircuit, advice: &Advice,
    memo_ct: &mut HashMap<GateId, AR16Encoding>,
    memo_times_s: &mut HashMap<(Level, GateId), AR16Encoding>,
) -> AR16Encoding {
    if let Some(v) = memo_times_s.get(&(k, w)) { return v.clone(); }

    // If k = k*: one-shot quadratic method (5.6)–(5.14).
    // If k > k*: Eq. (5.18) reduction then Eq. (5.19) quadratic:
    //   • linear terms from C_k: E_k(s^2), E_k(E_{k-1}(·)·s),
    //   • quadratic terms: level (k-1) encodings via eval_ct_gate(...).
    // Cache and return.
    todo!("assemble per (5.18)–(5.19)");
}
```
This ensures every `c^k` has the structural form `⟨Lin_f^k, C_k⟩ + Poly_f^k(C_1..C_{k-1})` (see (5.2)–(5.4)).

---

## 6. Traversal & Levels

Evaluate the circuit in **topological order**. If levels are not precomputed, annotate once:

```rust
/// Inputs/const-one → level 0; Add/Sub keep max(level); Mul raises by +1.
pub fn annotate_levels(poly: &PolyCircuit) -> HashMap<GateId, Level> { /* standard pass */ }
```

Enforce for Add/Sub that both inputs are at the same level; multiply raises by +1 deterministically.

---

## 7. Advice Generation (offline)

For a depth‑`d` layered circuit:
1. Build `C_1 = {E_1(x_i)}_i ∪ {E_1(s)}`.
2. For `k = 2..d`:
   - If layer `k` is **addition**: `C_k := C_{k-1}`.
   - If layer `k` is **multiplication**: materialize  
     `C_k = {E_k(z), E_k(z·s) : z∈C_{k-1}} ∪ {E_k(s^2)}`.

This is a **minimal sufficient** advice family for all EvalPK/EvalCT steps (both base case and inductive).

---

## 8. Design Q&A

- **Is `Advice` required by EvalPK?**  
  Yes, but please provide a labels‑only `AdvicePK`, but its content mirrors `C_k`.
---

## 9. Tests

- **Add/Sub**: Check (5.9)/(5.10) with noise neutralized in fixtures.  
- **First Mul**: Quadratic method matches (5.7)/(5.11) for both CT and PK.  
- **Later Mul**: Reconstruction follows (5.18)/(5.19); final assembly equals (5.24)/(5.25).  
- **Structure**: For random circuits, verify `c^k = ⟨Lin^k, C_k⟩ + Poly^k(C_1..C_{k-1})` (5.2)–(5.4).

---

## 10. References

- 2016 paper, §5 “Public Key and Ciphertext Evaluation Algorithms” (esp. (5.2)–(5.25)).
- `PolyCircuit`, `GateId`, `PolyGateType::{Input, Add, Sub, Mul}` in your codebase.
