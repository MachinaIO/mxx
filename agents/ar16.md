# ar16 Agent Guide

## Algorithm Overview
- **Goal**: Implement the EvalPK and EvalCT routines from Section 5 (“Public Key and Ciphertext Evaluation Algorithms”) of ePrint 2016/361 so that evaluated encodings satisfy Equation (5.1) for depth‑`d` NC¹ circuits: `CT(f(x)) = PK_f·s + p_{d-1}·η_{d-1} + μ_f(x) + f(x)`. All unit tests will set noise terms to zero and verify exact equality.
- **Encodings**: The evaluator receives the advice sets `C_k` exactly as defined on p. 21 of the paper: `C_1 = {E_1(x_i), E_1(s)}` and, for every multiplication layer `k`, `C_k = {E_k(C_{k-1}), E_k(C_{k-1}·s), E_k(s), E_k(s^2)} (the inclusion of `E_k(s)` ensures that any missing `E_k(c·s)` values can be recomputed on the evaluator side).`; addition layers reuse `C_{k-1}` unchanged. These encodings are the only inputs supplied by the encryptor—no additional higher-level data is assumed. The evaluation algorithm must combine them according to the quadratic method (Equations (5.6)–(5.14)) to reconstruct `c_k = E_k(f_k(x))`.
- **EvalPK**: Recursively labels each gate in the existing `PolyCircuit` with a public key `a`. Addition gates sum the child `a` polynomials. Multiplication gates consume the advice entries in `C_k`—specifically `E_k(C_{k-1})`, `E_k(C_{k-1}·s)`, and `E_k(s^2)`—and apply Equation (5.6) to obtain the new label `a`, following Equations (5.11)–(5.17) and Claim 5.5.
- **Eval Encoding**: Mirrors EvalPK for ciphertexts. Addition gates add child encodings. Multiplication gates consume the relevant entries from `C_k` and substitute them into Equation (5.6) to produce the next-level Regev pair—exactly as outlined on pp. 21–23.
- **Noise bookkeeping**: Encoding structs must remain pure `(a, b)` pairs; plaintext or noise terms must never be cached separately. Any zero-noise testing should decrypt by evaluating `b - a·s` with the supplied secret.

## Implementation Specification
- **Wire representation**: Use `circuit::GateId` directly for every wire; each gate’s output wire is identified by its `GateId`, so no extra alias is required.
- **Evaluator inputs**: `eval_public_key` / `eval_encoding` receive only level‑1 inputs—the `(a,b)` ciphertexts matching the circuit’s primary wires—and the circuit topology (including gate kinds and the per-gate `u` coefficients implied by the PolyCircuit). No higher-level encodings are supplied.
- **Initial advice data**:
  - Supply the advice sets `C_k` exactly as defined in the paper: `C_1 = {E_1(x_i), E_1(s)}`; for any multiplication layer `k`, `C_k = {E_k(C_{k-1}), E_k(C_{k-1}·s), E_k(s), E_k(s^2)} (the inclusion of `E_k(s)` ensures that any missing `E_k(c·s)` values can be recomputed on the evaluator side).`; addition layers reuse `C_{k-1}` verbatim.
  - Record the scalar labels `u_{k-1,i}` (derived from the `PolyCircuit` topology) so they can be applied in Equation (5.6) when processing multiplication gates.
  - No other encodings are supplied; evaluators must rely solely on the contents of each `C_k` to rebuild `E_k(f_k(x))`.
  - For bookkeeping it is convenient to maintain, for every element `c ∈ C_{k-1}`, the triple of level‑`k` encodings `{E_k(c), E_k(c·s), E_k(s^2)}` so they can be retrieved by `GateId` during evaluation.
- **Module layout** (`src/ar16`):
  - `mod.rs`: Re-export submodules, define the `(a,b)` structs (`AR16PublicKey`, `AR16Encoding`), and expose public APIs.
  - `advice.rs`: Provide lightweight metadata containers (`AdviceRole`, `AdviceSet`) for per-level scalar data (e.g., the `u` coefficients). These must not contain higher-level Regev ciphertexts.
  - `state.rs`: Maintain an `EvalContext` whose caches are seeded with level‑1 `(a,b)` inputs; any higher-level entries are reconstructed dynamically and memoised by `GateId`.
  - `eval_pk.rs`: Implement `eval_public_key` by recursively rebuilding multiplication-layer labels via Equation (5.6), consuming the level‑`k` advice entries.
  - `eval_encoding.rs`: Implement `eval_encoding` with the same recurrence, combining the advice entries with the child ciphertexts to obtain `E_k(f_k(x))`.
  - `quadratic.rs`: Encode Equations (5.6)–(5.11) verbatim, providing helpers that perform the Regev arithmetic for the quadratic combination.

### Multiplication Procedure with Advice Sets (Eq. 5.6)
For a multiplication gate at level `k` with children `g_i`, `g_j` and scalar labels `u_{k-1,i}`, `u_{k-1,j}`, perform the following steps (each memoises its result keyed by `GateId`):
1. **Recursively obtain child ciphertexts**: Evaluate (or look up) `E_{k-1}(c_{k-1,i}) = (a_i, b_i)` and `E_{k-1}(c_{k-1,j}) = (a_j, b_j)`. If these are not already cached, use the helpers below to rebuild them from lower levels.
2. **Lift child ciphertexts when needed**: When `E_{k-1}(c_{k-1,*})` is absent (e.g., for deeper levels), reconstruct it by repeatedly applying the quadratic method using the advice entries in `C_{k-1}`. Each lift produces the triple `{E_t(c), E_t(c·s), E_t(s^2)}` required to continue the recurrence.
3. **Read level-`k` advice**: From `C_k`, retrieve the entries `{E_k(c_{k-1,i}), E_k(c_{k-1,j}), E_k(c_{k-1,i}·s), E_k(c_{k-1,j}·s), E_k(s^2)}`. These are supplied by the encryptor for every element in `C_{k-1}`.
4. **Compute the quadratic base**: Multiply the child ciphertexts directly: `(a_i * b_j + a_j * b_i, b_i * b_j)`.
5. **Combine according to Equation (5.6)**: Use the advice entries to form 
   ```text
   E_k(c_{k-1}) = base
                + u_{k-1,i} u_{k-1,j} · E_k(s^2)
                − u_{k-1,j} · E_k(c_{k-1,i}·s)
                − u_{k-1,i} · E_k(c_{k-1,j}·s),
   ```
   with standard Regev arithmetic.
6. **Memoise the result**: Cache the resulting `(a,b)` pair and the new label `a` under the gate’s `GateId`; addition layers reuse `C_{k-1}` and sum the child `(a,b)`.

### Public Key Reconstruction
`EvalPK` mirrors the above but keeps only the label component. Using the advice entries in `C_k`, compute `u_k = u_{k-1,i}u_{k-1,j}·a_{s^2} − u_{k-1,j}·a_{c_i·s} − u_{k-1,i}·a_{c_j·s}` and memoise the resulting `AR16PublicKey<P>`.
## Unit Test Plan
- **Equation (5.1) checks**: For depth‑4 (base case) and deeper alternating circuits, supply only level‑1 `(a,b)` encodings (zero noise) and verify that the dynamically rebuilt ciphertexts decrypt to `f(x)` while satisfying `CT = PK_f·s + f(x)`.
- **Recursive correctness**: Assemble a depth‑6 alternating circuit, confirm that EvalPK/EvalCT rebuild intermediate encodings without prepopulated advice, and compare the results against a reference implementation.
- **Memoization**: Ensure each gate’s encoding/public key is recomputed at most once per evaluator run, even though the quadratic method is rebuilt dynamically.
- **Error handling**: Assert that missing scalar metadata (e.g., absent `u_{k-1}` values) surface as `Ar16Error::MissingAdvice` and unsupported gate kinds return `Ar16Error::UnsupportedGate`.

- [x] Standardize on `GateId` for wire identifiers throughout the AR16 module surface.
- [x] Define `AR16PublicKey` and `AR16Encoding` structs with modular arithmetic helpers.
- [ ] Build quadratic helper routines for the base case (Equations 5.6–5.14) and general step (Claims 5.4–5.5), consuming the advice entries `E_k(C_{k-1})`, `E_k(C_{k-1}·s)`, and `E_k(s^2)` as defined in the paper.
- [ ] Implement `eval_public_key` that consumes a `PolyCircuit`, the advice sets `C_k`, and scalar metadata, producing `EvalPkOutput` while applying Equation (5.6) at each multiplication layer.
- [ ] Implement `eval_encoding` that mirrors the above, combining the explicit advice entries with the child ciphertexts to obtain `E_k(f_k(x))`.
- [ ] Maintain the `(a,b)` abstraction without storing plaintext/noise helpers; limit any evaluation utilities to test code only.
- [ ] Seed deterministic fixtures under `test_data/ar16/` (only level-1 inputs) and expand `tests/test_ar16_eval.rs` to verify Equation (5.1) once dynamic recomputation passes.
- [ ] Document module responsibilities and a dynamic recomputation example in `src/ar16/mod.rs`, referencing this guide.
